# This workflow runs when a new tag starting with 'v' is pushed.
# It builds the plugin with the tag version, creates a GitHub Release, and uploads the final JAR.
#  For buils on github, push tags:
#  - git tag v1.0.0
#  - git push origin --tags
name: Build on tag

on:
  push:
    branches:
      - master
    tags:
      - "*"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"
          cache: maven

      - name: Prepare version and build number
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          BUILD_NUMBER="$(printf "%02d" "${GITHUB_RUN_NUMBER}")"
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            TAG="${GITHUB_REF_NAME#v}"
            echo "is_tag=true" >> "$GITHUB_OUTPUT"
            echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
            echo "src_version=${TAG}" >> "$GITHUB_OUTPUT"
          else
            LAST_TAG="$(git describe --tags --abbrev=0 2>/dev/null || true)"
            VERSION="$(mvn -B -DskipTests help:evaluate -Dexpression=project.version -q -DforceStdout)"
            TAG="${LAST_TAG#v}"
            if [[ -z "${TAG}" ]]; then
              TAG="${VERSION#v}"
            fi
            echo "is_tag=false" >> "$GITHUB_OUTPUT"
            echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
            echo "src_version=${VERSION}" >> "$GITHUB_OUTPUT"
          fi
          echo "build_number=${BUILD_NUMBER}" >> "$GITHUB_OUTPUT"

      - name: Set project version
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ steps.meta.outputs.is_tag }}" == "true" ]]; then
            mvn -B -DskipTests versions:set -DnewVersion="${{ steps.meta.outputs.tag }}" -DprocessAllModules=true -DgenerateBackupPoms=false
          fi

      - name: Build
        shell: bash
        run: |
          set -euo pipefail
          mvn -B -DskipTests -Dgpg.skip -Dmaven.javadoc.skip -Dmaven.source.skip -DBUILD_NUMBER="${{ steps.meta.outputs.build_number }}" clean package

      - name: Collect artifact
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${{ steps.meta.outputs.tag }}"
          SRC_VERSION="${{ steps.meta.outputs.src_version }}"
          BUILD_NUMBER="${{ steps.meta.outputs.build_number }}"
          SRC="RedProtect-Spigot/target/RedProtect-${SRC_VERSION}.jar"
          DEST_DIR="dist"
          if [[ "${{ steps.meta.outputs.is_tag }}" == "true" ]]; then
            DEST="${DEST_DIR}/RedProtect-${VERSION}-b${BUILD_NUMBER}-release.jar"
          else
            DEST="${DEST_DIR}/RedProtect-SNAPSHOT-b${BUILD_NUMBER}.jar"
          fi
          if [ ! -f "$SRC" ]; then
            echo "Expected jar not found: $SRC"
            ls -la RedProtect-Spigot/target
            exit 1
          fi
          mkdir -p "$DEST_DIR"
          cp "$SRC" "$DEST"
          shopt -s nullglob
          ADDON_SOURCES=()
          if compgen -G "add-ons/*.jar" > /dev/null; then
            ADDON_SOURCES+=(add-ons/*.jar)
          fi
          if compgen -G "Addons/*/target/*.jar" > /dev/null; then
            ADDON_SOURCES+=(Addons/*/target/*.jar)
          fi
          ADDON_COUNT=0
          for ADDON in "${ADDON_SOURCES[@]}"; do
            ADDON_BASE="$(basename "$ADDON")"
            if [[ "${ADDON_BASE}" != *-"${SRC_VERSION}".jar ]]; then
              continue
            fi
            ADDON_BASE_NO_EXT="${ADDON_BASE%.jar}"
            ADDON_BASE_NO_VER="${ADDON_BASE_NO_EXT%-${SRC_VERSION}}"
            if [[ "${{ steps.meta.outputs.is_tag }}" == "true" ]]; then
              ADDON_NAME="${ADDON_BASE_NO_VER}-${VERSION}-b${BUILD_NUMBER}-release-addon.jar"
            else
              ADDON_NAME="${ADDON_BASE_NO_VER}-SNAPSHOT-b${BUILD_NUMBER}-addon.jar"
            fi
            cp "$ADDON" "${DEST_DIR}/${ADDON_NAME}"
            ADDON_COUNT=$((ADDON_COUNT + 1))
          done
          if [ "$ADDON_COUNT" -eq 0 ]; then
            echo "No add-ons found for version: ${SRC_VERSION}"
            ls -la add-ons || true
            ls -la Addons || true
            exit 1
          fi

      - name: Prepare artifact links
        id: artifact_links
        shell: bash
        run: |
          set -euo pipefail
          BUILD_NUMBER="${{ steps.meta.outputs.build_number }}"
          if [[ "${{ steps.meta.outputs.is_tag }}" == "true" ]]; then
            TAG_NAME="${GITHUB_REF_NAME}"
          else
            TAG_NAME="SNAPSHOT-b${BUILD_NUMBER}"
          fi
          BASE_URL="https://github.com/${GITHUB_REPOSITORY}/releases/download/${TAG_NAME}"
          PLUGIN_LINKS=""
          ADDON_LINKS=""
          for FILE in dist/*.jar; do
            NAME="$(basename "$FILE")"
            URL="${BASE_URL}/${NAME}"
            LINK="- [${NAME}](${URL})\n"
            if [[ "${NAME}" == *"-addon.jar" ]]; then
              ADDON_LINKS="${ADDON_LINKS}${LINK}"
            else
              PLUGIN_LINKS="${PLUGIN_LINKS}${LINK}"
            fi
          done
          if [[ -z "${PLUGIN_LINKS}" ]]; then
            PLUGIN_LINKS="- (no plugin artifact found)\n"
          fi
          if [[ -z "${ADDON_LINKS}" ]]; then
            ADDON_LINKS="- (no add-on artifacts found)\n"
          fi
          echo "plugin_links<<EOF" >> "$GITHUB_OUTPUT"
          printf "%b" "${PLUGIN_LINKS}" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "addon_links<<EOF" >> "$GITHUB_OUTPUT"
          printf "%b" "${ADDON_LINKS}" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Generate release notes
        id: release
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.tag }}"
          BUILD_NUMBER="${{ steps.meta.outputs.build_number }}"
          PREV_TAG=""
          if [[ "${{ steps.meta.outputs.is_tag }}" == "true" ]]; then
            PREV_TAG="$(git describe --tags --abbrev=0 "${GITHUB_REF_NAME}^" 2>/dev/null || true)"
          else
            PREV_TAG="$(git describe --tags --abbrev=0 2>/dev/null || true)"
          fi
          NOTES_FILE="release_notes.md"
          if [[ "${{ steps.meta.outputs.is_tag }}" == "true" ]]; then
            echo "RedProtect-${TAG}-b${BUILD_NUMBER}" > release_name.txt
          else
            echo "RedProtect-SNAPSHOT-b${BUILD_NUMBER}" > release_name.txt
          fi
          if [ -n "$PREV_TAG" ]; then
            echo "## Changes since ${PREV_TAG}:" > "$NOTES_FILE"
            if [[ "${{ steps.meta.outputs.is_tag }}" == "true" ]]; then
              CHANGELOG="$(git log --pretty=format:"- %s (%h)" "${PREV_TAG}..${GITHUB_REF_NAME}")"
            else
              CHANGELOG="$(git log --pretty=format:"- %s (%h)" "${PREV_TAG}..HEAD")"
            fi
          else
            YEAR="$(date +%Y)"
            echo "## Changes:" > "$NOTES_FILE"
            CHANGELOG="$(git log --pretty=format:"- %s (%h)" --since="${YEAR}-01-01" "HEAD")"
          fi
          echo "${CHANGELOG}" >> "$NOTES_FILE"
          echo "" >> "$NOTES_FILE"
          echo "## Hashes:" >> "$NOTES_FILE"
          echo "\`\`\`" >> "$NOTES_FILE"
          (cd dist && sha256sum *) >> "$NOTES_FILE"
          echo "\`\`\`" >> "$NOTES_FILE"
          echo "notes_file=${NOTES_FILE}" >> "$GITHUB_OUTPUT"
          echo "release_name=$(cat release_name.txt)" >> "$GITHUB_OUTPUT"
          echo "raw_changelog<<EOF" >> "$GITHUB_OUTPUT"
          echo "${CHANGELOG}" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.meta.outputs.is_tag == 'true' && github.ref_name || format('SNAPSHOT-b{0}', steps.meta.outputs.build_number) }}
          name: ${{ steps.release.outputs.release_name }}
          body_path: ${{ steps.release.outputs.notes_file }}
          prerelease: ${{ steps.meta.outputs.is_tag != 'true' }}
          files: |
            dist/*.jar

      - name: Send Discord Embed
        shell: bash
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          WEBHOOK_USERNAME: Jenkins
          WEBHOOK_AVATAR_URL: https://www.jenkins.io/images/logos/jenkins/jenkins.png
          RELEASE_NAME: ${{ steps.release.outputs.release_name }}
          BUILD_NUMBER: ${{ steps.meta.outputs.build_number }}
          BUILD_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          PLUGIN_LINKS: ${{ steps.artifact_links.outputs.plugin_links }}
          ADDON_LINKS: ${{ steps.artifact_links.outputs.addon_links }}
          RAW_CHANGELOG: ${{ steps.release.outputs.raw_changelog }}
        run: |
          set -euo pipefail
          python - <<'PY' > payload.json
          import json, os

          def truncate(text, limit=900):
              text = text.strip()
              if len(text) <= limit:
                  return text
              return text[:limit].rsplit("\n", 1)[0] + "\n- ... (truncated)"

          release_name = os.environ.get("RELEASE_NAME", "RedProtect Build")
          build_number = os.environ.get("BUILD_NUMBER", "")
          build_url = os.environ.get("BUILD_URL", "")
          plugin_links = os.environ.get("PLUGIN_LINKS", "").strip()
          addon_links = os.environ.get("ADDON_LINKS", "").strip()
          changelog = truncate(os.environ.get("RAW_CHANGELOG", ""))
          username = os.environ.get("WEBHOOK_USERNAME", "Jenkins")
          avatar_url = os.environ.get("WEBHOOK_AVATAR_URL", "")

          title = f"RedProtect #{build_number}" if build_number else release_name
          artifacts = ""
          if plugin_links:
              artifacts += plugin_links
          if addon_links:
              if artifacts:
                  artifacts += "\n"
              artifacts += addon_links

          embed = {
              "title": title,
              "url": build_url,
              "color": 0x2ecc71,
              "fields": [
                  {"name": "Build", "value": build_number or "-", "inline": True},
                  {"name": "Status", "value": "success", "inline": True},
                  {"name": "Changes", "value": changelog or "-"},
                  {"name": "Artifacts", "value": artifacts or "-", "inline": False},
              ],
          }

          payload = {
              "username": username,
              "avatar_url": avatar_url,
              "embeds": [embed],
          }
          print(json.dumps(payload))

          curl -sS -H "Content-Type: application/json" -d @payload.json "${DISCORD_WEBHOOK_URL}"
